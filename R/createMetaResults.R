#' Computes the metaResults analysis
#'
#' This function computes the metaResults analysis, which basically aims to statistically quantify the impact of each gene on the overall survival of patients using the bootstrapping approach.
#'
#' @param selectedGenesOnly A boolean indicating if all the genes (if set to `FALSE`) or only a given subset of genes (if set to `TRUE`) should be used for the computation. If set to `TRUE`, the desired genes to investigate should be contained in a single column table. Please see the online tutorial for more information.
#'
#' @param signaturesMode A boolean determining if the analysis should be conducted on an input data table referring to gene signatures enrichments (if set to `TRUE`) instead of individual genes (if set to `FALSE`). Although very unlikely to be used, this could still be useful if you have access to other metrics than direct gene expression that you want to confront on overall survival.
#'
#' @param minNumberOfPatientsPerGroup An integer indicating the minimum number of patients per group to consider. If the number of patients for each group (that is to say, the low, intermediate and high expression of the current gene) is below this threshold, the associated gene is skipped and all the related values generated by the function are replaced by zeros.
#'
#' @param unsollicitedCores An integer indicating the number of CPU cores to let free of solicitation. This is useful to impeach the computer to freeze.
#'
#' @param iterationsPerCluster An integer indicating the number of iterations (that is to say, random sampling steps) to perform independently for each gene. The higher this value, the more reliable are the results, but the longer the computation time is.
#'
#' @param genesCutoff An integer indicating the gene expression quantile to consider as both low/intermediate and intermediate/high thresholds for the construction of the low, intermediate and high expression groups for the current gene. For instance, a value of 15 means that, for each gene, the 15% most-expressing patients will be in the high expression group, the 15% least-expressing patients will be in the low expression group, and the remaining (here 70%) will be in the intermediate expression group.
#'
#' @param verbose A boolean determining if the function should regularly output its progression in the console (if set to `TRUE`).
#'
#' @return Generated output files are exported to the `output > metaResults` folder. Their precise amounts and organization varies according to the `selectedGenesOnly` and `signaturesMode` arguments (see the online tutorial for more details).
#'
#' @importFrom foreach %do%
#' @importFrom foreach %dopar%
#'
#' @export

createMetaResults = function(selectedGenesOnly = FALSE, signaturesMode = FALSE, minNumberOfPatientsPerGroup = 5, unsollicitedCores = 2, iterationsPerCluster = 16, genesCutoff = 15, verbose = TRUE)
{
  basisFolder = getwd()
  
  if(selectedGenesOnly == TRUE)
  {
    unlink(file.path("output", "metaResults", "selectedGenes", "survivalCurves", "*"), recursive = TRUE, force = TRUE)
    unlink(file.path("output", "metaResults", "selectedGenes", "survivalTables", "*"), recursive = TRUE, force = TRUE)
    unlink(file.path("output", "metaResults", "metaResults_selectedGenes.meta"))
  } else
  {
    unlink(file.path("output", "metaResults", "metaResults.meta"))
  }	
  
  if(verbose == TRUE)
  {
    print("## Opening fullData file ##")
  }
  
  if(signaturesMode == TRUE)
  {
    selectedGenesOnly = FALSE
    fileToLoad = list.files(file.path("output", "data"), pattern = "signaturesData.data")
  } else
  {
    fileToLoad = list.files(file.path("output", "data"), pattern = "^fullData.data$")
  }
  
  fullGenesDataPath = file.path("output", "data", fileToLoad)
  fullGenesData = data.table::fread(input = fullGenesDataPath, sep = "\t", header = TRUE, data.table = FALSE, stringsAsFactors = FALSE)
  
  if(selectedGenesOnly == TRUE)
  {
    genesToKeepFileName = list.files(file.path("output", "data", "input"))
    genesToKeepPath = file.path(file.path("output", "data", "input"), genesToKeepFileName)
    genesToKeep = data.table::fread(input = genesToKeepPath, sep = "\t", header = TRUE, data.table = FALSE, stringsAsFactors = FALSE)
    genesToKeep = genesToKeep[order(genesToKeep$HGNC_GeneSymbol),]
    rownames(genesToKeep) = NULL
  
    RNASeqData = as.data.frame(fullGenesData[, colnames(fullGenesData) %in% genesToKeep])
    RNASeqData = as.data.frame(RNASeqData[,order(colnames(RNASeqData))])
    
    colnames(RNASeqData) = genesToKeep
    
    fullGenesData = cbind(fullGenesData[, 1:3], RNASeqData)
  }
  
  allColnames = colnames(fullGenesData)[-c(1:3)]
  
  if(selectedGenesOnly == FALSE)
  {
    nonNumericData = fullGenesData[, c(1:3)]
    fullGenesData = fullGenesData[, -c(1:3)]
    
    fullGenesData = fullGenesData[, colnames(fullGenesData[, ]) %in% allColnames]
    fullGenesData = cbind(nonNumericData, fullGenesData)
  }
  
  if(verbose == TRUE)
  {
    print("## Beginning of the analysis (may be long) ##")
  }
  
  patientsVitalStatus = fullGenesData$vitalStatus
  patientsVitalStatus = gsub("Alive", "0", patientsVitalStatus)
  patientsVitalStatus = gsub("Dead", "1", patientsVitalStatus)
  patientsVitalStatus = as.numeric(patientsVitalStatus)
  fullGenesData$vitalStatus = patientsVitalStatus
  
  if(signaturesMode == TRUE)
  {
    selectedGenesOnly = TRUE
  }
  
  if(selectedGenesOnly == TRUE)
  {
    g = NULL
    
    foreach::foreach(g = 1:length(allColnames)) %do%
      {
        currentGeneName = allColnames[g]
        
        currentDirectoryPath_survivalCurves = file.path("output", "metaResults", "selectedGenes", "survivalCurves", currentGeneName)
        currentDirectoryPath_survivalTables = file.path("output", "metaResults", "selectedGenes", "survivalTables", currentGeneName)
        
        if(dir.exists(currentDirectoryPath_survivalCurves) == TRUE)
        {
          unlink(file.path("output", "metaResults_selectedGenes", "survivalCurves", currentGeneName, "*.*"))
        } else
        {
          dir.create(currentDirectoryPath_survivalCurves, showWarnings = TRUE, recursive = FALSE)
        }
        
        if(dir.exists(currentDirectoryPath_survivalTables) == TRUE)
        {
          unlink(file.path("output", "metaResults_selectedGenes", "survivalTables", currentGeneName, "*.*"))
        } else
        {
          dir.create(currentDirectoryPath_survivalTables, showWarnings = TRUE, recursive = FALSE)
        }
      }	
  }
  
  coresNumber = parallel::detectCores() - as.numeric(unsollicitedCores)
  
  cl = parallel::makeCluster(coresNumber, type = "PSOCK")
  doSNOW::registerDoSNOW(cl)
  
  f = NULL
  
  bootstrapIterations = coresNumber*iterationsPerCluster
  cutoffToUse = genesCutoff
  
  if(verbose == TRUE)
  {
    print(paste("## Going for ", bootstrapIterations, " bootstrapping iterations (", coresNumber, " cores used * ", iterationsPerCluster, " iterations per cluster) with genes cutoff = ", cutoffToUse, " ##", sep = ""))
  }
  
  samplesNumberToKeep = ceiling(nrow(fullGenesData)/2)
  bootstrapIterationsPerCluster = ceiling(bootstrapIterations/coresNumber)
  
  bestCutoffsCompilation = foreach::foreach(f = 1:coresNumber, .packages = c("foreach", "tcltk", "survival", "data.table")) %dopar%
    {
      pb = tcltk::tkProgressBar(max = bootstrapIterationsPerCluster)
      
      i = NULL
      
      totalIterationsMatrix = foreach::foreach(i = 1:bootstrapIterationsPerCluster) %do%
        {
          currentBootstrapData = fullGenesData[sample(1:nrow(fullGenesData), samplesNumberToKeep), ]
          currentIterationMatrix = matrix(0, nrow = ncol(fullGenesData)-3, ncol = 8)
          
          x = NULL
          
          currentIterationForCurrentChunk = foreach::foreach(x = 4:ncol(currentBootstrapData)) %do%
          {				
            currentGeneBootstrapData = data.frame(currentBootstrapData[, c(1:3, x)], stringsAsFactors = FALSE)
              
            currentGeneBootstrapData$vitalStatus = as.numeric(currentGeneBootstrapData$vitalStatus)
            currentGeneBootstrapData$survivedDays = as.numeric(currentGeneBootstrapData$survivedDays)
            currentGeneBootstrapData[,4] = as.numeric(currentGeneBootstrapData[,4])
              
            valuesPercentageSummary = table(fullGenesData[,x])/length(fullGenesData[,x])
            mostFrequentValuePercentage = as.numeric(valuesPercentageSummary[1])
              
            if(mostFrequentValuePercentage <= 0.25)
            {
              quantiles = stats::quantile(as.numeric(currentGeneBootstrapData[,4]), probs = c(cutoffToUse/100, 1-cutoffToUse/100), type = 7, na.rm = TRUE)
                
              if(as.numeric(quantiles[1]) != as.numeric(quantiles[2]))
              {
                currentGeneBootstrapData$group = 1
                  
                replaceID_Low = which(currentGeneBootstrapData[,4] < as.numeric(quantiles[1]))
                replaceID_High = which(currentGeneBootstrapData[,4] >= as.numeric(quantiles[2]))
                nbOfLowPatients = length(replaceID_Low)
                nbOfHighPatients = length(replaceID_High)
                nbOfInterPatients = nrow(currentGeneBootstrapData) - nbOfLowPatients - nbOfHighPatients
                  
                currentGeneBootstrapData$group[replaceID_Low] = 0
                currentGeneBootstrapData$group[replaceID_High] = 2
                  
                currentGeneBootstrapData$group = as.numeric(currentGeneBootstrapData$group)
                  
                if(length(unique(currentGeneBootstrapData$group)) == 3)
                {
                  if(nbOfLowPatients >= minNumberOfPatientsPerGroup & nbOfInterPatients >= minNumberOfPatientsPerGroup & nbOfHighPatients >= minNumberOfPatientsPerGroup)
                  {
                    dataInterVSLow = currentGeneBootstrapData[currentGeneBootstrapData$group == 0 | currentGeneBootstrapData$group == 1,]
                    dataInterVSHigh = currentGeneBootstrapData[currentGeneBootstrapData$group == 1 | currentGeneBootstrapData$group == 2,]
                      
                    if(length(unique(dataInterVSLow$vitalStatus)) == 2 & length(unique(dataInterVSHigh$vitalStatus)) == 2)
                    {
                      InterVSLowSurvival = summary(survival::coxph(Surv(survivedDays, vitalStatus) ~ group, data = dataInterVSLow))
                      InterVSHighSurvival = summary(survival::coxph(Surv(survivedDays, vitalStatus) ~ group, data = dataInterVSHigh))
                        
                      LogRankLow = as.numeric(InterVSLowSurvival$sctest[1])
                      LogRankHigh = as.numeric(InterVSHighSurvival$sctest[1])
                      pValueLow = as.numeric(InterVSLowSurvival$sctest[3])
                      pValueHigh = as.numeric(InterVSHighSurvival$sctest[3])
                        
                      meanExpressionGene = as.numeric(mean(currentGeneBootstrapData[,4], na.rm = TRUE))
                      sdExpressionGene = as.numeric(stats::sd(currentGeneBootstrapData[,4], na.rm = TRUE))
                        
                      currentIterationResults = c(meanExpressionGene, sdExpressionGene, LogRankLow, LogRankHigh, pValueLow, pValueHigh)
                    } else
                    {
                      currentIterationResults = c(0, 0, 0, 0, 0, 0)
                    }
                  } else
                  {
                    currentIterationResults = c(0, 0, 0, 0, 0, 0)
                  }
                } else
                {
                  currentIterationResults = c(0, 0, 0, 0, 0, 0)
                }							
              } else
              {
                currentIterationResults = c(0, 0, 0, 0, 0, 0)
              }
            } else
            {
              currentIterationResults = c(0, 0, 0, 0, 0, 0)
            }
              
            return(currentIterationResults)
          }
          
          currentIterationForCurrentChunk = do.call(rbind, currentIterationForCurrentChunk)
          currentIterationMatrix[, 1] = cutoffToUse
          currentIterationMatrix[, 2:7] = currentIterationForCurrentChunk
          currentIterationMatrix[, 8] = i
          
          tcltk::setTkProgressBar(pb, i, label=paste("Bootstrapping : ", i, "/", bootstrapIterationsPerCluster, " iterations done", sep = ""))
          
          return(currentIterationMatrix)
        }
      
      totalIterationsMatrix = do.call(rbind, totalIterationsMatrix)				
      close(pb)
      
      totalGeneNames = rep(colnames(currentBootstrapData)[-c(1:3)], bootstrapIterationsPerCluster)
      totalIterationsMatrix = data.frame(cbind(totalGeneNames, totalIterationsMatrix), stringsAsFactors = FALSE)
      
      colnames(totalIterationsMatrix) = c("gene", "cutoff", "MeanExpressionGene", "SDExpressionGene", "LogrankLow", "LogrankHigh", "pValueLow", "pValueHigh", "iteration")
      
      rowsToDelete_ID = which(totalIterationsMatrix$MeanExpressionGene == 0)
      
      if(length(rowsToDelete_ID) > 0)
      {
        totalIterationsMatrix = totalIterationsMatrix[-rowsToDelete_ID, ]
      }
      
      return(totalIterationsMatrix)
    }
  
  bestCutoffsCompilation = do.call(rbind, bestCutoffsCompilation)
  parallel::stopCluster(cl)
  
  gc()
  
  coresNumber = parallel::detectCores()
  
  chunks = itertools::isplitVector(unique(bestCutoffsCompilation$gene), chunks = coresNumber)
  
  cl2 = parallel::makeCluster(coresNumber, type = "PSOCK")
  doSNOW::registerDoSNOW(cl2)
  
  g = NULL
  
  finalMetaResults = foreach::foreach(g = chunks, .packages = c("foreach", "tcltk", "survival", "data.table", "survRM2", "stats")) %dopar%
    {
      pb2 = tcltk::tkProgressBar(max = length(g))
      
      # Debug only :
      # g = nextElem(chunks)
      # g = g[, 1:10]
      
      finalRownames = NULL
      
      currentChunkMetaResults = data.frame(matrix(0, nrow = length(g), ncol = 8), stringsAsFactors = FALSE)
      
      e = NULL
      
      foreach::foreach(e = 1:length(g)) %do%
      {
        currentGene = as.character(g[e])
        currentGeneData = bestCutoffsCompilation[bestCutoffsCompilation$gene == currentGene, ]
          
        currentAssociatedCutoff = as.numeric(unique(currentGeneData$cutoff)[1])
        currentAssociatedMeanExpression = mean(as.numeric(currentGeneData$MeanExpressionGene), na.rm = TRUE)
        currentAssociatedSDExpression = mean(as.numeric(currentGeneData$SDExpressionGene), na.rm = TRUE)
          
        currentGeneLowLogrankMean = mean(as.numeric(currentGeneData$LogrankLow), na.rm = TRUE)
        currentGeneHighLogrankMean = mean(as.numeric(currentGeneData$LogrankHigh), na.rm = TRUE)
          
        if(nrow(currentGeneData) > 1)
        {
          currentGeneLowLogrankSD = stats::sd(as.numeric(currentGeneData$LogrankLow), na.rm = TRUE)
          currentGeneHighLogrankSD = stats::sd(as.numeric(currentGeneData$LogrankHigh), na.rm = TRUE)
        } else
        {
          currentGeneLowLogrankSD = 0
          currentGeneHighLogrankSD = 0
        }
          
        currentGeneLowLogrankPvalueMean = mean(as.numeric(currentGeneData$pValueLow), na.rm = TRUE)
        currentGeneHighLogrankPvalueMean = mean(as.numeric(currentGeneData$pValueHigh), na.rm = TRUE)
          
        if(currentAssociatedMeanExpression == 0 | currentAssociatedSDExpression == 0)
        {
          currentAssociatedSNRExpression = 0
        } else
        {
          currentAssociatedSNRExpression = currentAssociatedMeanExpression/currentAssociatedSDExpression
        }
          
        if(currentGeneLowLogrankMean == 0 | currentGeneLowLogrankSD == 0)
        {
          currentGeneDataLowSNR = 0
        } else
        {
          currentGeneDataLowSNR = currentGeneLowLogrankMean/currentGeneLowLogrankSD
        }
          
        if(currentGeneHighLogrankMean == 0 | currentGeneHighLogrankSD == 0)
        {
          currentGeneDataHighSNR = 0
        } else
        {
          currentGeneDataHighSNR = currentGeneHighLogrankMean/currentGeneHighLogrankSD
        }
          
        currentGeneID = which(colnames(fullGenesData) == currentGene)
        filteredData = fullGenesData[, c(1:3, currentGeneID)]
        colnames(filteredData)[4] = currentGene
          
        currentGeneQuantiles = stats::quantile(as.numeric(filteredData[, currentGene]), probs = seq(0, 1, 0.01), type = 7, na.rm = TRUE)
          
        lowThreshold = as.numeric(currentGeneQuantiles[currentAssociatedCutoff + 1])
        highThreshold = as.numeric(currentGeneQuantiles[length(currentGeneQuantiles) - currentAssociatedCutoff])
          
        filteredData$group = 1
          
        filteredData[as.numeric(filteredData[,currentGene]) <= lowThreshold, "group"] = 0
        filteredData[as.numeric(filteredData[,currentGene]) >= highThreshold, "group"] = 2
          
        if(length(unique(filteredData$group)) == 3)
        {
          if(selectedGenesOnly == TRUE)
          {			
            survivalObjectGlobal = survival::Surv(time = filteredData$survivedDays, event = filteredData$vitalStatus)
            survivalCurves = survival::survfit(survivalObjectGlobal ~ group, data = filteredData, conf.type = "log-log")
              
            nLow = as.numeric(survivalCurves$n[1])
            nHigh = as.numeric(survivalCurves$n[3])
            nInt = as.numeric(survivalCurves$n[2])
              
            legendText = paste("nLow = ", nLow, ", nInt = ", nInt, ", nHigh = ", nHigh, " - Cutoff = ", genesCutoff, "%", sep = "")
              
            survivalCurvesColors = c("green", "black", "red")
            typeOfDots = c(1,1,1)
            weightOfLines = c(2,2,2)
            legendKeys = c("Low", "Intermediate", "High")
              
            pathToSave = file.path(basisFolder, "output", "metaResults", "selectedGenes", "survivalCurves", currentGene, paste("cutoff=", genesCutoff, "_", currentGene, "_survivalCurve.pdf", sep = ""))
              
            grDevices::pdf(pathToSave)
            graphics::plot(
              survivalCurves,
              col = survivalCurvesColors,
              xlab = "Time (days)",
              ylab = "Overall Survival",
              lty=typeOfDots,
              lwd=weightOfLines,
              log = FALSE,
              main = paste("Current mRNA : ", currentGene, sep = ""),
            )
            graphics::legend(100, 0.2, legendKeys, lty = 1:1, lwd = 2:2, col = survivalCurvesColors)
            graphics::mtext(legendText, side=3, adj=0.5, cex=0.8)
            
            grDevices::dev.off()
            
            groupedData = data.frame(NULL)
            
            h = NULL
            
            foreach::foreach(h = 1:length(rownames(filteredData))) %do%
            {
              currentCase = filteredData[e,]
                  
              groupedData[h,"CaseUUID"] = as.vector(currentCase$CaseUUID)
              groupedData[h,"vitalStatus"] = as.vector(currentCase$vitalStatus)
              groupedData[h,"survivedDays"] = as.vector(currentCase$survivedDays)
                  
              if(as.numeric(currentCase$group) == 0)
              {
                if(as.factor(currentCase$vitalStatus) == 0)
                {
                  groupedData[h,"lowExpression"] = 0
                } else
                {
                  groupedData[h,"lowExpression"] = 1
                }	
                    
                groupedData[h,"intermediateExpression"] = ""
                groupedData[h,"highExpression"] = ""
              }
                  
              if(as.numeric(currentCase$group) == 1)
              {
                groupedData[h,"lowExpression"] = ""	
                
                if(as.factor(currentCase$vitalStatus) == 0)
                {
                  groupedData[h,"intermediateExpression"] = 0
                } else
                {
                  groupedData[h,"intermediateExpression"] = 1
                }
                    
                groupedData[h,"highExpression"] = ""
              }
                  
              if(as.numeric(currentCase$group) == 2)
              {
                groupedData[h,"lowExpression"] = ""	
                groupedData[h,"intermediateExpression"] = ""
                
                if(as.factor(currentCase$vitalStatus) == 0)
                {
                  groupedData[h,"highExpression"] = 0
                } else
                {
                  groupedData[h,"highExpression"] = 1
                }
              }
            }
              
            utils::write.table(groupedData, row.names = FALSE, col.names = TRUE, quote = FALSE, file = file.path(basisFolder, "output", "metaResults", "selectedGenes", "survivalTables", currentGene, paste("cutoff=", genesCutoff, "_", currentGene, "_survivalTable.txt", sep = "")), sep = "\t")
            }
            
            data_lowAndInter = filteredData[filteredData$group != 2,]
            data_lowAndInter[data_lowAndInter$group == 0, "arm"] = 0
            data_lowAndInter[data_lowAndInter$group == 1, "arm"] = 1
            
            data_interAndHigh = filteredData[filteredData$group != 0,]
            data_interAndHigh[data_interAndHigh$group == 1, "arm"] = 0
            data_interAndHigh[data_interAndHigh$group == 2, "arm"] = 1
            
            data_lowAndHigh = filteredData[filteredData$group != 1,]
            data_lowAndHigh[data_lowAndHigh$group == 0, "arm"] = 0
            data_lowAndHigh[data_lowAndHigh$group == 2, "arm"] = 1
            
            lowAndInter_results = survRM2::rmst2(data_lowAndInter$survivedDays, data_lowAndInter$vitalStatus, data_lowAndInter$arm)
            interAndHigh_results = survRM2::rmst2(data_interAndHigh$survivedDays, data_interAndHigh$vitalStatus, data_interAndHigh$arm)
            
            RMST_low = as.numeric(lowAndInter_results$RMST.arm0$rmst[1])
            RMST_inter = as.numeric(lowAndInter_results$RMST.arm1$rmst[1])
            RMST_high = as.numeric(interAndHigh_results$RMST.arm1$rmst[1])
            
            currentResultsDf = t(data.frame(RMST_low, RMST_inter, RMST_high, stringsAsFactors = FALSE))
            rownames(currentResultsDf) = c("LOW", "INTER", "HIGH")
            currentResultsDf = currentResultsDf[order(currentResultsDf),]
            currentResultsDf_colNames = names(currentResultsDf)
            currentResultsDf_colNames = paste(currentResultsDf_colNames, collapse = "<")
            currentGeneClass = "N/A"
            
            if(currentResultsDf_colNames == "INTER<LOW<HIGH")
            {
              currentGeneClass = 1
            } else if(currentResultsDf_colNames == "INTER<HIGH<LOW")
            {
              currentGeneClass = 2
            } else if(currentResultsDf_colNames == "HIGH<LOW<INTER")
            {
              currentGeneClass = 3
            } else if(currentResultsDf_colNames == "HIGH<INTER<LOW")
            {
              currentGeneClass = 4
            } else if(currentResultsDf_colNames == "LOW<HIGH<INTER")
            {
              currentGeneClass = 5
            } else if(currentResultsDf_colNames == "LOW<INTER<HIGH")
            {
              currentGeneClass = 6
            }
          } else
          {
            currentGeneClass = 0
          }
          
          finalRownames = c(finalRownames, currentGene)
          
          currentChunkMetaResults[e,] = c(currentAssociatedCutoff, currentGeneClass, currentGeneClass, currentAssociatedSNRExpression, currentGeneDataLowSNR, currentGeneLowLogrankPvalueMean, currentGeneDataHighSNR, currentGeneHighLogrankPvalueMean)
          
          tcltk::setTkProgressBar(pb2, e, label=paste("Synthesizing : ", round(e/length(g), 2)*100, "% done", sep = ""))
        }		
      
      rownames(currentChunkMetaResults) = finalRownames
      currentChunkMetaResults = cbind(rownames(currentChunkMetaResults), currentChunkMetaResults)
      
      colnames(currentChunkMetaResults) = c("HGNC_GeneSymbol", "Cutoff", "AssociatedSetting", "Class", "Gene_SNR_Expression", "Inter_VS_Low_MeanSNR", "Inter_VS_Low_MeanPvalue", "Inter_VS_High_MeanSNR", "Inter_VS_High_MeanPvalue")
      
      paradoxGenes_ID =  which(currentChunkMetaResults$Class == 1 | currentChunkMetaResults$Class == 2)
      currentChunkMetaResults[paradoxGenes_ID, "AssociatedSetting"] = "paradox"
      
      inverseParadoxGenes_ID =  which(currentChunkMetaResults$Class == 3 | currentChunkMetaResults$Class == 5)
      currentChunkMetaResults[inverseParadoxGenes_ID, "AssociatedSetting"] = "inverseParadox"
      
      correlationGenes_ID =  which(currentChunkMetaResults$Class == 6)
      currentChunkMetaResults[correlationGenes_ID, "AssociatedSetting"] = "correlation"
      
      inverseCorrelationGenes_ID =  which(currentChunkMetaResults$Class == 4)
      currentChunkMetaResults[inverseCorrelationGenes_ID, "AssociatedSetting"] = "inverseCorrelation"
      
      noSettingGenes_ID =  which(currentChunkMetaResults$Class == 0)
      currentChunkMetaResults[noSettingGenes_ID, "AssociatedSetting"] = "NA"
      
      currentChunkMetaResults$GeneScore = (currentChunkMetaResults$Inter_VS_Low_MeanSNR*(1 - currentChunkMetaResults$Inter_VS_Low_MeanPvalue)) + (currentChunkMetaResults$Inter_VS_High_MeanSNR*(1 - currentChunkMetaResults$Inter_VS_High_MeanPvalue))
      currentChunkMetaResults = currentChunkMetaResults[order(currentChunkMetaResults$GeneScore, decreasing = TRUE),]
      
      close(pb2)
      
      return(currentChunkMetaResults)
    }
  
  parallel::stopCluster(cl2)
  
  gc()
  
  finalMetaResults = do.call(rbind, finalMetaResults)
  
  if(verbose == TRUE)
  {
    print("## Exporting summary table of best determined cutoffs ##")
  }
  
  if(selectedGenesOnly == TRUE)
  {
    if(signaturesMode == TRUE)
    {
      utils::write.table(finalMetaResults, row.names = FALSE, col.names = TRUE, quote = FALSE, file = file.path("output", "metaResults", paste("metaResults_signatures.meta", sep = "")), sep = "\t")
    } else
    {
      utils::write.table(finalMetaResults, row.names = FALSE, col.names = TRUE, quote = FALSE, file = file.path("output", "metaResults", paste("metaResults_selectedGenes.meta", sep = "")), sep = "\t")
    }
  } else
  {
    utils::write.table(finalMetaResults, row.names = FALSE, col.names = TRUE, quote = FALSE, file = file.path("output", "metaResults", paste("metaResults.meta", sep = "")), sep = "\t")
  }
  
  if(selectedGenesOnly == TRUE)
  {
    if(verbose == TRUE)
    {
      print("## Zipping the selectedGenes folder ##")
    }

    previouswd = getwd()
    setwd(file.path("output", "metaResults", "selectedGenes"))
    filesToZip = list.files(pattern = "*", recursive = TRUE)
    filesToDiscard = grep("*\\.zip", filesToZip)
    
    if(length(filesToDiscard) > 0)
    {
      filesToZip = filesToZip[-filesToDiscard]
    }

    if(signaturesMode == TRUE)
    {
      zipFileName = "selectedGenes_signatures.zip"
    } else
    {
      zipFileName = "selectedGenes.zip"
    }

    zip::zipr(zipfile = zipFileName, files = filesToZip)

    unlink(filesToZip, force = TRUE, recursive = TRUE)
    directoriesToDelete = c(list.dirs(path = "survivalCurves")[-1], list.dirs(path = "survivalTables")[-1])
    unlink(directoriesToDelete, force = TRUE, recursive = TRUE)
    setwd(previouswd)
  }
  
  sink(file.path("silentOutput.log"))
  gc()
  sink()
}